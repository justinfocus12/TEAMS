
This repository contains code for running the TEAMS algorithm, as well as more general ensemble-generating procedures for dynamical systems. Among the included examples are the Frierson GCM featured in Finkel & O'Gorman (2025), as well as the Lorenz-96 system featured in Finkel & O'Gorman (2024). The summary below is meant to convey the general design of the codebase, which aims to be extensible to new algorithms and new dynamical systems. But the implementation is not professional, and will certainly need case-by-case modification. Interested readers are highly encouraged to contact Justin Finkel (justinfocus12@gmail.com) for guidance on using it. Still, we hope that the core ideas conveyed here, in the publications, and in the code structure will help to facilitate community uptake of our methods. 

I. The driver code hierarchy: dynamical systems and algorithms for running them in ensemble mode
    A. DynamicalSystem class (dynamicalsystem.py): specification of required methods for defining any new system, the most important one being "run_trajectory". This method takes four arguments beyond the implicit "self" parameter (self gives the rule for stepping forward in time).
        - The first argument, "icandf", stands for "initial conditions and forcing", and contains all the needed information to (deterministically) provide the initial condition and generate noise, be it in the form of a one-off kick to the initial condition, a sequence of such perturbations, or an integer seed for generating a white noise sequence. All these versions can be found in the Forcing class (forcing.py), and one can implement more versions of forcing such as Levy noise if one wanted to. Because an icandf dictionary must be supplied to every run, any concrete implementation of DynamicalSystem must implement its own "generate_default_icandf" method. The role of this "icandf" dictionary is crucial, as it provides the extra input necessary beyond the evolution rule The same file implements "ODESystem" and "SDESystem" for ordinary and stochastic differential equations. An SDESystem instance has an ODESystem instance as an instance variable(e.g., the SDE $dX = -aX dt + b dW$, has the ODE $dx/dt = -ax$ as an instance variable). Both of those must be specified further for particular systems, such as Lorenz-96 as done in the examples. If ">" means "is a superclass of", DynamicalSystem > SDESystem > Lorenz96. For the Frierson GCM, more customization is necessary, and so the "FriersonGCM" class implemented in examples/frierson_gcm directly extends DynamicalSystem: DynamicalSystem > FriersonGCM. 
        - The second argument is "obs_fun": a function handle for any observable of special interest that we should evaluate online while running the model. Technically mandatory, but you could just have it return None. 
        - The third argument is "saveinfo": a dictionary that specified how to save out the data, including possibly the initial condition and different fields in different output files. Its structure is different for each dynamical system. 
        - The fourth argument is "root_dir": the directory relative to which all output data is stored. This is helpful if one needs to migrate the entire ensemble from one location to another and only have to change one variable in the objects saved to disk. 
    B. Ensemble class (ensemble.py) specifies a data structure for managing large, and growing, ensembles of simulations stored on the disk. It uses a networkx graph to represent relationships between ensemble members, and is agnostic to the type of dynamical system. Any Ensemble instance has a DynamicalSystem instance as an attribute. Any call to DynamicalSystem.run_trajectory must go through the Ensemble instance that contains the DynamicalSystem instance. 
    C. EnsembleAlgorithm class (algorithms.py): in general, an EnsembleAlgorithm is a rule for generating the next member in an Ensemble given its current state. TEAMS is one example; DNS is another example with a very simple rule of extending the previous simulation chunk, picking it up at the endpoint; and "PeriodicBranching" is another example that we used to calculate ensemble dispersion rates in Finkel and O'Gorman (2025). Each of these is specified as a still-abstract subclass in the algorithms.py file, and the concrete implementations are completed in the examples subfolder. E.g., FriersonGCMTEAMS < TEAMS < EnsembleAlgorithm, and Lorenz96TEAMS < SDETEAMS < TEAMS < EnsembleAlgorithm.
II. The Lorenz96 system, implemented in examples/lorenz96, is a good example to follow if implementing an algorithm on a new SDESystem. 
III. The Frierson GCM 
    A. As a DynamicalSystem object, it is implemented as "FriersonGCM" in examples/frierson_gcm/frierson_gcm.py. The core methods like "run_trajectory" merely wrap, via system calls, a large Fortran codebase that exists in some other directory, which is specified in a "config" dictionary, which must be supplied when creating an instance of FriersonGCM (see __init__ method). See the "default_config" method for a template. In our case, that codebase is in the companion repository "jf_conv_gray_smooth". 
IV.  TEAMS on the Frierson GCM
V.   PeriodicBranching on the Frierson GCM
